# DevJourney – Copilot Instructions

You are helping build DevJourney, a practice-first coding education platform with:
- Flutter frontend (mobile + web)
- NestJS API (TypeScript + Prisma + BullMQ)
- Runner service (NestJS/Node) executing user code in Docker
- AI-service calling OpenAI to generate progressive hints
- PostgreSQL as main DB, Redis for cache/queue

Coding rules:
- Use TypeScript strict mode on backend.
- Use Riverpod + Dio on Flutter.
- Prefer small, focused modules and services.
- Respect clean architecture: controllers -> services -> repositories.

When I ask you to "implement" something, you must:
- Generate concrete code files with imports.
- Use environment variables: DATABASE_URL, REDIS_URL, JWT_SECRET, RUNNER_SECRET, AI_API_KEY.
- Make sure endpoints match:
    - POST /auth/login
    - POST /submissions
    - GET /submissions/:id
    - POST /runner/callback
    - POST /ai/hint

Security:
- Validate all DTOs.
- Runner must be treated as untrusted; verify HMAC on /runner/callback.
- Do NOT hardcode secrets.

Focus on:
- Good DX (developer experience).
- Clear separation between API, Runner, AI-service.
- Extensibility for adding more languages later.

Respond with complete files when possible.



Общая последовательность действий

Создать монорепозиторий с папками: apps/api, apps/runner, apps/ai-service, apps/flutter, infra/.

Настроить PostgreSQL + Redis через docker-compose.

Поднять API (NestJS + Prisma):

Auth, Users, Tracks, Courses, Lessons, Challenges, Submissions.

Поднять Runner (NestJS или чистый Node):

принимает job’ы, запускает код в Docker-контейнере, шлёт callback.

Сделать AI-service (NestJS):

прокси к OpenAI, подсказки, разбор ошибок.

Подключить Flutter-клиент:

экраны: логин, список курсов, список задач, экран задачи с редактором.

Добавить WebSocket прогресс сабмита.

Подключить AI-подсказки в UI.

Завести базовые тесты, окружение dev через Docker.

Ниже — по каждому шагу: что делать + промпт для Copilot.

1. Создаём монорепо и структуру
Шаг 1.1 — Инициализация проекта

Открой пустую папку, в терминале:

git init
pnpm init -y   # или npm init -y
pnpm add -D typescript ts-node nodemon
mkdir apps infra
mkdir apps/api apps/runner apps/ai-service apps/flutter

Промпт для Copilot (структура репо)
You are an expert full-stack architect.

Create a folder structure for a monorepo called "devjourney" with:
- apps/api        -> NestJS backend API (TypeScript + Prisma + BullMQ)
- apps/runner     -> Node.js/NestJS runner service for executing user code in Docker
- apps/ai-service -> NestJS service that calls OpenAI API and returns hints
- apps/flutter    -> Flutter client app

Also create:
- infra/docker-compose.yml (Postgres + Redis + API + Runner + AI-service)
- .editorconfig, .gitignore, README.md

Return:
- a tree structure
- recommended devDependencies for the root package.json (prettier, eslint, etc.)
- explanation of how packages will be linked.


Скопируй ответ Copilot в свой репозиторий и подправь при необходимости.

2. Настройка infra: PostgreSQL + Redis + docker-compose
Шаг 2.1 — docker-compose

Создай infra/docker-compose.yml и кинь Copilot такой промпт:

You are a senior DevOps engineer.

Create a docker-compose.yml for the dev environment of project "DevJourney" with services:
- postgres (image postgres:16, user: devjourney, password: devpass, db: devjourney)
- redis (image redis:7)
- api (build from ./apps/api, depends on postgres and redis, port 3000)
- runner (build from ./apps/runner, depends on redis and api)
- ai-service (build from ./apps/ai-service, depends on api and redis)

Requirements:
- map postgres port 5432:5432
- map redis port 6379:6379
- mount postgres volume "pgdata"
- all services in one default network
- api and runner use .env file from repo root
Return a complete docker-compose.yml compatible with version "3.9".

Шаг 2.2 — .env

Создай .env в корне проекта:

NODE_ENV=development
PORT=3000

DATABASE_URL=postgresql://devjourney:devpass@postgres:5432/devjourney
REDIS_URL=redis://redis:6379

JWT_SECRET=change_me
JWT_REFRESH_SECRET=change_me_refresh
JWT_EXPIRES=15m
JWT_REFRESH_EXPIRES=7d

RUNNER_CALLBACK_URL=http://api:3000/runner/callback
RUNNER_SECRET=super_runner_secret

AI_PROVIDER=openai
AI_API_KEY=sk-XXX


(потом заменишь ключ).

3. Backend API (NestJS + Prisma + BullMQ)
Шаг 3.1 — Создать NestJS API

В apps/api:

cd apps
nest new api
# или с помощью Copilot:


Промпт в Copilot Chat:

You are an expert NestJS backend engineer.

Inside apps/api, initialize a NestJS project "api" configured for:
- TypeScript
- Swagger/OpenAPI
- Prisma ORM with PostgreSQL
- BullMQ with Redis for job queue "grading"
- JWT authentication (access + refresh tokens)

Generate:
- AuthModule, UsersModule, TracksModule, CoursesModule, LessonsModule, ChallengesModule, SubmissionsModule
- each module with controller/service and DTOs
- a HealthModule with GET /health endpoint

Return step-by-step commands (nest generate ...) plus code snippets for:
- main.ts
- AppModule with all modules imported

Шаг 3.2 — Prisma схема (подай Copilot готовый контекст)

Создай apps/api/prisma/schema.prisma и используй этот промпт (можно с частью того, что я давал ранее):

You are a Prisma schema expert.

Create a Prisma schema for PostgreSQL that models:
- User, Track, Course, Module, Lesson, Challenge, ChallengeTest, Submission, Exam, ExamQuestion, ExamAttempt, Certificate, XpEvent, AiHintEvent.

Constraints:
- User has many Submissions, XpEvents, ExamAttempts, Certificates.
- Course belongs to Track; Module belongs to Course; Lesson belongs to Module; Challenge belongs to Lesson.
- Challenge has many ChallengeTests and Submissions.
- Use uuid string id for Submission; integers with autoincrement for most other IDs.
- Add useful indexes for queries: submissions by (userId, challengeId, createdAt).
Return a complete schema.prisma file.


Потом:

cd apps/api
pnpm add prisma @prisma/client
npx prisma generate
npx prisma migrate dev --name init

Шаг 3.3 — Submissions + очередь BullMQ

Промпт:

You are an experienced NestJS + BullMQ developer.

In NestJS API (apps/api):
Implement SubmissionsModule with:
- DTO for POST /submissions: { challengeId: number, code: string, lang: string }
- Controller with:
    - POST /submissions -> creates Submission in database with status "PENDING", enqueues a BullMQ job "grading" with submissionId, challengeId, code, lang.
    - GET /submissions/:id -> returns submission with status, score, runtime, memory, test results.
- Service that uses Prisma to insert/update Submission.
- BullMQ producer for queue "grading" using Redis URL from env.

Return TypeScript code for submissions.controller.ts, submissions.service.ts, and BullMQ queue provider.

4. Runner (Node/NestJS, Docker executor)
Шаг 4.1 — Инициализировать Runner

В apps/runner:

nest new runner


Промпт:

You are building a Runner service in NestJS.

Goal:
- Subscribe to BullMQ queue "grading".
- For each job, run user code in a Docker container with:
  - specific language image (python:3.11-slim for now),
  - mounted tests directory as read-only,
  - time/memory limits,
  - no outbound network.

Steps:
1) Configure BullMQ consumer in Runner.
2) Implement DockerService that:
   - creates container,
   - runs user code,
   - captures stdout/stderr, exit code,
   - enforces timeout.
3) After execution, call API callback endpoint /runner/callback with:
   - submissionId, score, runtimeMs, memoryKb, per-test results.

Return:
- RunnerModule skeleton,
- BullMQ consumer setup,
- DockerService interface and a simple implementation using dockerode (with TODO for security hardening).

Шаг 4.2 — Callback в API

Вернись в apps/api и дай Copilot промпт:

You are a NestJS backend engineer.

Implement RunnerCallbackController in API with endpoint:
POST /runner/callback

Request body:
{
  "submissionId": "uuid",
  "score": number,
  "status": "FINISHED" | "ERROR",
  "runtimeMs": number,
  "memoryKb": number,
  "tests": [
    { "name": string, "passed": boolean, "runtimeMs": number }
  ],
  "logsUrl": string | null
}

Requirements:
- verify X-Runner-Signature HMAC header using RUNNER_SECRET from env.
- update Submission in Postgres with new status, score, runtime, memory.
- store test results in a separate table (SubmissionTest) or JSON.
- emit WebSocket event "submissionUpdated" to the client.

Return controller + service code snippets with basic validation.

5. AI-service (NestJS + OpenAI)
Шаг 5.1 — Инициализация

В apps/ai-service:

nest new ai-service


Промпт:

You are designing an AI hint service for a coding learning platform.

In NestJS app "ai-service":
- Implement POST /ai/hint endpoint:
    Body: {
      "challengeText": string,
      "userCode": string,
      "failingOutput": string | null,
      "attempts": number,
      "locale": "uk" | "ru" | "en"
    }
- Call OpenAI Chat Completion API (model: gpt-4 or similar).
- Use a strong system prompt:
    - You are "DevJourney Helper", a coding tutor.
    - Give progressive hints (no full solution if attempts < 3).
    - Respond in user's locale.
    - Explain errors and propose next step.
- Return JSON: { level, hintText, partialCode, explain }.

Use AiService class that reads AI_API_KEY from env.
Return complete controller + service example.

Шаг 5.2 — System prompt (запиши в конфиг)

Сделай файл apps/ai-service/src/prompts/system.ts и попроси Copilot:

Write a TypeScript constant `DEVJOURNEY_SYSTEM_PROMPT_UA` for OpenAI ChatCompletion that:

- defines the assistant as "DevJourney Helper", a coding tutor,
- responses in Ukrainian by default,
- uses progressive hints (levels 1–5),
- forbids giving a full ready-made solution before 3 failed attempts,
- is focused on helping the student understand the algorithm, not just copy code.

Return a single exported constant string with this policy text in Ukrainian.

6. Flutter-приложение
Шаг 6.1 — Инициализация Flutter

В папке apps/flutter:

flutter create devjourney


Обнови pubspec.yaml (можно промптом):

You are a Flutter architect.

Update pubspec.yaml for a DevJourney app that uses:
- hooks_riverpod for state management
- dio for HTTP requests
- flutter_secure_storage for tokens
- web_socket_channel for WebSockets
- code_text_field + highlight for code editor on mobile
Prepare dependencies and dev_dependencies sections.

Шаг 6.2 — Клиент API и авторизация

Промпт:

You are a Flutter developer.

Implement:
- ApiClient class using Dio with baseUrl from const (e.g. http://localhost:3000).
- AuthRepository with methods login(email, password), register(...), refreshToken().
- TokenInterceptor for Dio that:
    - attaches access token to Authorization header,
    - refreshes token on 401 via refreshToken() and retries once.

Use hooks_riverpod to provide ApiClient and AuthRepository.
Return Dart code for api_client.dart, auth_repository.dart, and providers.

Шаг 6.3 — Экран логина
Create a Flutter `LoginPage` widget that:
- uses hooks_riverpod to watch AuthRepository,
- has TextFields for email and password,
- button "Увійти" that calls login(),
- shows loading state and error snackbar,
- on success, navigates to `TracksPage`.

Use Material 3, responsive layout.
Return complete Dart code.

Шаг 6.4 — Список треков/курсов
Implement `TracksPage` and `CoursesPage`:
- TracksPage: fetch GET /tracks, display cards with title, level.
- CoursesPage: given a trackId, fetch GET /courses?trackId, show progress for each course.
Use Riverpod async providers for loading states.
Return Dart code (widgets + providers).

Шаг 6.5 — Экран задачи с редактором и сабмитом
You are a Flutter dev building a coding challenge screen.

Implement `ChallengePage` that:
- receives challengeId,
- fetches GET /challenge/:id (title, description, examples).
- shows a code editor with syntax highlighting (for now, just a CodeField for Python).
- has buttons:
    - "Запустити" -> POST /submissions, then opens WebSocket to track progress.
    - "Підказка від AI" -> POST /ai/hint via API, shows hint in a side panel.

Use Riverpod for:
- challenge state
- submission state (status, score, logs)
- hint state

Make UI adaptive for mobile portrait view.

7. Подключение всего вместе
Как всё соединяется

Запускаешь infra:

cd infra
docker compose up -d


API:

cd apps/api

pnpm start:dev (или npm run start:dev)
Убедись, что миграции применены: npx prisma migrate dev.

Runner:

cd apps/runner

pnpm start:dev

Проверяешь, что он читает очередь grading из Redis.

AI-service:

cd apps/ai-service

pnpm start:dev

Flutter:

cd apps/flutter

flutter run (или flutter run -d chrome для web)

В api_client.dart поставь baseUrl на твой API (например http://localhost:3000 для web или через свой IP для телефона).